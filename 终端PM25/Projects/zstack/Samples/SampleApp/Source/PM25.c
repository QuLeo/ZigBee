/****************************************************************************
* 文 件 名: PM25.c
* 作    者: 权
* 修    订: 2013-01-08
* 版    本: 寄存器版本，在实际的协议栈中使用的是库函数，此头文件提供变量设置1.0
* 描    述: 设置串口波特率：9600bps 8N1
*           串口接收到PM25传感器返回的数据，通过解析获得PM25数据
****************************************************************************/
#include <ioCC2530.h>
#include <string.h>
#include <stdio.h>
#include <PM25.h>
uchar count1;
uchar RxBuf;
char UartState;
char RxData[SIZE];        //存储发送字符串




/****************************************************************************
* 名    称: DelayMS()
* 功    能: 以毫秒为单位延时
* 入口参数: msec 延时参数，值越大，延时越久
* 出口参数: 无
****************************************************************************/
void DelayMS(uint msec)
{ 
    uint i,j;
    
    for (i=0; i<msec; i++)
        for (j=0; j<1070; j++);
}

/****************************************************************************
* 名    称: InitUart()
* 功    能: 串口初始化函数
* 入口参数: 无
* 出口参数: 无
****************************************************************************/
void InitUart(void)
{ 
    PERCFG = 0x00;           //外设控制寄存器 USART 0的IO位置:0为P0口位置1 
    P0SEL = 0x0c;            //P0_2,P0_3用作串口（外设功能）
    P2DIR &= ~0xC0;          //P0优先作为UART0
    
    U0CSR |= 0x80;           //设置为UART方式
    U0GCR |= 8;				       
    U0BAUD |= 59;           //波特率设为9600
    UTX0IF = 0;              //UART0 TX中断标志初始置位0
    U0CSR |= 0x40;           //允许接收 
    IEN0 |= 0x84;            //开总中断允许接收中断  
}

/****************************************************************************
* 名    称: UartSendString()
* 功    能: 串口发送函数
* 入口参数: Data:发送缓冲区   len:发送长度
* 出口参数: 无
****************************************************************************/
void UartSendString(char *Data, int len)
{
    uint i;
    
    for(i=0; i<len; i++)
    {
        U0DBUF = *Data++;
        while(UTX0IF == 0);
        UTX0IF = 0;
    }
}


/****************************************************************************
* 名    称: UART0_ISR(void) 串口中断处理函数 
* 描    述: 当串口0产生接收中断，将收到的数据保存在RxBuf中
****************************************************************************/
#pragma vector = URX0_VECTOR 
__interrupt void UART0_ISR(void) 
{ 
    URX0IF = 0;       // 清中断标志 
    RxBuf = U0DBUF; 
    if(UartState == UART0_RX)              //接收状态 
        {  
                
                if((RxBuf != 0xAB)&&(count1 < 10))//以'AB'为结束符,一次最多接收50个字符            
                {
                  RxData[count1++] = RxBuf;
                }
                else
                {
                    if(count1 >= 10)             //判断数据合法性，防止溢出
                    {
                        count1 = 0;              //计数清0
                        UartState = UART0_TX;
                        memset(RxData, 0, SIZE);//清空接收缓冲区
                    }
                    else
                        UartState = UART0_TX;  //进入发送状态 
                }
        }
}